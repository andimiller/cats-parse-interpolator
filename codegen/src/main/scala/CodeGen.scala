import cats.effect.{IO, IOApp}
import fs2.io.file.{Files, Path}
import fs2._

object CodeGen extends IOApp.Simple {

  def templateApplicative(name: String, pair: String, end: String, functor: String, input: String)(params: Int): String = params match {
    case i =>
      val params      = ('A' to 'Z').take(i).mkString("[", ", ", "]")
      val output      = ('A' to 'Z').take(i).mkString("(", ", ", ")")
      val args        = ('a' to 'z').take(i).map(c => s"p$c: $functor[${c.toUpper}]").mkString(", ")
      val deconstruct = ('a' to 'z').take(i + 1).mkString(" :: ")
      val lastString  = ('a' to 'z').apply(i)
      val pairs       = ('a' to 'z').take(i).map(c => s"$pair($c, p$c)").mkString(", ")
      s"""
         |  def $name$params($args): $functor[$output] = $input match {
         |    case $deconstruct :: Nil =>
         |      ($pairs)${if (i > 1) ".tupled" else ""} <* $end($lastString)
         |  }
         |""".stripMargin
  }

  def templateMonad(
      name: String,
      pair1: String,
      pair2: String,
      end1: String,
      end2: String,
      functor1: String,
      functor2: String,
      input: String
  )(
      params: Int
  ): String =
    params match {
      case i =>
        val params       = ('A' to 'Z').take(i).mkString("[", ", ", "]")
        val output       = ('A' to 'Z').take(i).mkString("(", ", ", ")")
        val args         = ('a' to 'z')
          .map {
            case 'a' => s"pa: $functor1[A]"
            case c   => s"p$c: $functor2[${c.toUpper}]"
          }
          .take(i)
          .mkString(", ")
        val deconstruct  = s"(a, ${('b' to 'z').take(i).mkString(" :: ")} :: Nil)"
        val lastString   = ('a' to 'z').apply(i)
        val pairs        = ('a' to 'z').slice(1, i).map(c => s"$pair2($c, p$c)").mkString(", ")
        val resultsMatch = ('b' to 'z').take(i - 1).map(c => s"${c}r").mkString("(", ", ", ")")
        val resultsTuple = ('a' to 'z').take(i).map(c => s"${c}r").mkString("(", ", ", ")")
        s"""
         |  def $name$params($args): $functor1[$output] = $input match {
         |    case $deconstruct =>
         |      $pair1(a, pa).flatMap { ar =>
         |        ($pairs).${if (i == 2) "map" else "mapN"}{ case $resultsMatch => $resultsTuple } <* $end2($lastString)
         |      }
         |  }
         |""".stripMargin
    }

  val head =
    """package net.andimiller.cats.parse
      |
      |import cats.parse._
      |import cats.implicits._
      |
      |import scala.annotation.nowarn
      |
      |// THIS FILE IS AUTOGENERATED USING TEMPLATES, SEE CODEGEN MODULE
      |package object interpolator {
      |    @nowarn("msg=not.*?exhaustive") // we do a lot of things here with matching on Lists which are a known length
      |    implicit class ParserHelperApplicative(val sc: StringContext) extends AnyVal {
      |      private def nonEmptyParts: List[Option[String]]                 =
      |        sc.parts.toList.map(s => Option(s).filter(_.nonEmpty))
      |      private def partsSafeHead: (Option[String], List[String]) =
      |        Option(sc.parts.head).filter(_.nonEmpty) -> sc.parts.tail.toList
      |      private def pair[T](s: Option[String], p: Parser[T]): Parser[T] = s match {
      |        case Some(value) => Parser.string(value) *> p
      |        case None        => p
      |      }
      |      private def pair0[T](s: String, p: Parser0[T]): Parser0[T]      = Parser.string0(s) *> p
      |      private def endParser(last: Option[String]): Parser0[Unit]      =
      |        last match {
      |          case Some(value) => Parser.string(value)
      |          case None        => Parser.unit
      |        }
      |      private def endParser0(last: String): Parser0[Unit]             = Parser.string0(last)
      |
      |     def p(): Parser[Unit]     = Parser.string(sc.parts.mkString)
      |     def p0(): Parser0[Unit]   = Parser.string0(sc.parts.mkString)
      |     def pm(): Parser[Unit]     = Parser.string(sc.parts.mkString)
      |
      |""".stripMargin
  val tail =
    """  }
      |}
      |""".stripMargin

  override def run: IO[Unit] = {
    val pa       = templateApplicative("p", "pair", "endParser", "Parser", "nonEmptyParts")(_)
    val p0a      = templateApplicative("p0", "pair0", "endParser0", "Parser0", "sc.parts.toList")(_)
    val pm       = templateMonad("pm", "pair", "pair0", "endParser", "endParser0", "Parser", "Parser0", "partsSafeHead")(_)
    val pm1      = templateApplicative("pm", "pair", "endParser", "Parser", "nonEmptyParts")(_)
    val generate =
      List(
        List(head),
        (1 to 22).map(pa),
        (1 to 22).map(p0a),
        List(pm1(1)),
        (2 to 22).map(pm),
        List(tail)
      ).flatten

    Stream
      .emits(generate)
      .covary[IO]
      .through(
        Files[IO].writeUtf8Lines(Path("./src/main/scala/net/andimiller/cats/parse/interpolator/package.scala"))
      )
      .compile
      .drain
  }

}
