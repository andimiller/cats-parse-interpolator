import cats.effect.{IO, IOApp}
import fs2.io.file.{Files, Path}
import fs2._

object CodeGen extends IOApp.Simple {

  def template(name: String, pair: String, end: String, functor: String, input: String)(params: Int): String = params match {
    case i =>
      val params      = ('A' to 'Z').take(i).mkString("[", ", ", "]")
      val output      = ('A' to 'Z').take(i).mkString("(", ", ", ")")
      val args        = ('a' to 'z').take(i).map(c => s"p$c: $functor[${c.toUpper}]").mkString(", ")
      val deconstruct = ('a' to 'z').take(i + 1).mkString(" :: ")
      val lastString  = ('a' to 'z').apply(i)
      val pairs       = ('a' to 'z').take(i).map(c => s"$pair($c, p$c)").mkString(", ")
      s"""
         |  def $name$params($args): $functor[$output] = $input match {
         |    case $deconstruct :: Nil =>
         |      ($pairs)${if (i > 1) ".tupled" else ""} <* $end($lastString)
         |  }
         |""".stripMargin
  }

  val head =
    """package net.andimiller.cats.parse
      |
      |import cats.parse._
      |import cats.implicits._
      |
      |import scala.annotation.nowarn
      |
      |// THIS FILE IS AUTOGENERATED USING TEMPLATES, SEE CODEGEN MODULE
      |package object interpolator {
      |  @nowarn("msg=not.*?exhaustive") // we do a lot of things here with matching on Lists which are a known length
      |  implicit class ParserHelper(val sc: StringContext) extends AnyVal {
      |    private def nonEmptyParts: List[Option[String]]                 =
      |      sc.parts.toList.map(s => Option(s).filter(_.nonEmpty))
      |    private def pair[T](s: Option[String], p: Parser[T]): Parser[T] = s match {
      |      case Some(value) => Parser.string(value) *> p
      |      case None        => p
      |    }
      |    private def pair0[T](s: String, p: Parser0[T]): Parser0[T]      = Parser.string0(s) *> p
      |    private def endParser(last: Option[String]): Parser0[Unit]      =
      |      last match {
      |        case Some(value) => Parser.string(value)
      |        case None        => Parser.unit
      |      }
      |    private def endParser0(last: String): Parser0[Unit]             = Parser.string0(last)
      |
      |   def p(): Parser[Unit]                                                                                                    = Parser.string(sc.parts.mkString)
      |   def p0(): Parser0[Unit]                                                                                                  = Parser.string0(sc.parts.mkString)
      |
      |""".stripMargin
  val tail =
    """  }
      |}
      |""".stripMargin

  override def run: IO[Unit] = {
    val p        = template("p", "pair", "endParser", "Parser", "nonEmptyParts")(_)
    val p0       = template("p0", "pair0", "endParser0", "Parser0", "sc.parts.toList")(_)
    val generate = {
      Stream.emit(head) ++
        Stream
          .emits(
            (1 to 22).map(p) ++ (1 to 22).map(p0)
          ) ++ Stream.emit(tail)
    }
    generate
      .covary[IO]
      .through(
        Files[IO].writeUtf8Lines(Path("./src/main/scala/net/andimiller/cats/parse/interpolator/package.scala"))
      )
      .compile
      .drain
  }

}
