package net.andimiller.cats.parse

import cats.parse._
import cats.implicits._

import scala.annotation.nowarn

// THIS FILE IS AUTOGENERATED USING TEMPLATES, SEE CODEGEN MODULE
package object interpolator {
  @nowarn("msg=not.*?exhaustive") // we do a lot of things here with matching on Lists which are a known length
  implicit class ParserHelper(val sc: StringContext) extends AnyVal {
    private def nonEmptyParts: List[Option[String]]                 =
      sc.parts.toList.map(s => Option(s).filter(_.nonEmpty))
    private def pair[T](s: Option[String], p: Parser[T]): Parser[T] = s match {
      case Some(value) => Parser.string(value) *> p
      case None        => p
    }
    private def pair0[T](s: String, p: Parser0[T]): Parser0[T]      = Parser.string0(s) *> p
    private def endParser(last: Option[String]): Parser0[Unit]      =
      last match {
        case Some(value) => Parser.string(value)
        case None        => Parser.unit
      }
    private def endParser0(last: String): Parser0[Unit]             = Parser.string0(last)

    def p(): Parser[Unit]   = Parser.string(sc.parts.mkString)
    def p0(): Parser0[Unit] = Parser.string0(sc.parts.mkString)

    def p[A](pa: Parser[A]): Parser[(A)] = nonEmptyParts match {
      case a :: b :: Nil =>
        (pair(a, pa)) <* endParser(b)
    }

    def p[A, B](pa: Parser[A], pb: Parser[B]): Parser[(A, B)] = nonEmptyParts match {
      case a :: b :: c :: Nil =>
        (pair(a, pa), pair(b, pb)).tupled <* endParser(c)
    }

    def p[A, B, C](pa: Parser[A], pb: Parser[B], pc: Parser[C]): Parser[(A, B, C)] = nonEmptyParts match {
      case a :: b :: c :: d :: Nil =>
        (pair(a, pa), pair(b, pb), pair(c, pc)).tupled <* endParser(d)
    }

    def p[A, B, C, D](pa: Parser[A], pb: Parser[B], pc: Parser[C], pd: Parser[D]): Parser[(A, B, C, D)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: Nil =>
        (pair(a, pa), pair(b, pb), pair(c, pc), pair(d, pd)).tupled <* endParser(e)
    }

    def p[A, B, C, D, E](pa: Parser[A], pb: Parser[B], pc: Parser[C], pd: Parser[D], pe: Parser[E]): Parser[(A, B, C, D, E)] =
      nonEmptyParts match {
        case a :: b :: c :: d :: e :: f :: Nil =>
          (pair(a, pa), pair(b, pb), pair(c, pc), pair(d, pd), pair(e, pe)).tupled <* endParser(f)
      }

    def p[A, B, C, D, E, F](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F]
    ): Parser[(A, B, C, D, E, F)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: Nil =>
        (pair(a, pa), pair(b, pb), pair(c, pc), pair(d, pd), pair(e, pe), pair(f, pf)).tupled <* endParser(g)
    }

    def p[A, B, C, D, E, F, G](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G]
    ): Parser[(A, B, C, D, E, F, G)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: Nil =>
        (pair(a, pa), pair(b, pb), pair(c, pc), pair(d, pd), pair(e, pe), pair(f, pf), pair(g, pg)).tupled <* endParser(h)
    }

    def p[A, B, C, D, E, F, G, H](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H]
    ): Parser[(A, B, C, D, E, F, G, H)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: Nil =>
        (pair(a, pa), pair(b, pb), pair(c, pc), pair(d, pd), pair(e, pe), pair(f, pf), pair(g, pg), pair(h, ph)).tupled <* endParser(i)
    }

    def p[A, B, C, D, E, F, G, H, I](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I]
    ): Parser[(A, B, C, D, E, F, G, H, I)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi)
        ).tupled <* endParser(j)
    }

    def p[A, B, C, D, E, F, G, H, I, J](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J]
    ): Parser[(A, B, C, D, E, F, G, H, I, J)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj)
        ).tupled <* endParser(k)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk)
        ).tupled <* endParser(l)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K, L](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K],
        pl: Parser[L]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K, L)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk),
          pair(l, pl)
        ).tupled <* endParser(m)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K, L, M](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K],
        pl: Parser[L],
        pm: Parser[M]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K, L, M)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk),
          pair(l, pl),
          pair(m, pm)
        ).tupled <* endParser(n)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K, L, M, N](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K],
        pl: Parser[L],
        pm: Parser[M],
        pn: Parser[N]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K, L, M, N)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk),
          pair(l, pl),
          pair(m, pm),
          pair(n, pn)
        ).tupled <* endParser(o)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K],
        pl: Parser[L],
        pm: Parser[M],
        pn: Parser[N],
        po: Parser[O]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk),
          pair(l, pl),
          pair(m, pm),
          pair(n, pn),
          pair(o, po)
        ).tupled <* endParser(p)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K],
        pl: Parser[L],
        pm: Parser[M],
        pn: Parser[N],
        po: Parser[O],
        pp: Parser[P]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk),
          pair(l, pl),
          pair(m, pm),
          pair(n, pn),
          pair(o, po),
          pair(p, pp)
        ).tupled <* endParser(q)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K],
        pl: Parser[L],
        pm: Parser[M],
        pn: Parser[N],
        po: Parser[O],
        pp: Parser[P],
        pq: Parser[Q]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk),
          pair(l, pl),
          pair(m, pm),
          pair(n, pn),
          pair(o, po),
          pair(p, pp),
          pair(q, pq)
        ).tupled <* endParser(r)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K],
        pl: Parser[L],
        pm: Parser[M],
        pn: Parser[N],
        po: Parser[O],
        pp: Parser[P],
        pq: Parser[Q],
        pr: Parser[R]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: s :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk),
          pair(l, pl),
          pair(m, pm),
          pair(n, pn),
          pair(o, po),
          pair(p, pp),
          pair(q, pq),
          pair(r, pr)
        ).tupled <* endParser(s)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K],
        pl: Parser[L],
        pm: Parser[M],
        pn: Parser[N],
        po: Parser[O],
        pp: Parser[P],
        pq: Parser[Q],
        pr: Parser[R],
        ps: Parser[S]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: s :: t :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk),
          pair(l, pl),
          pair(m, pm),
          pair(n, pn),
          pair(o, po),
          pair(p, pp),
          pair(q, pq),
          pair(r, pr),
          pair(s, ps)
        ).tupled <* endParser(t)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K],
        pl: Parser[L],
        pm: Parser[M],
        pn: Parser[N],
        po: Parser[O],
        pp: Parser[P],
        pq: Parser[Q],
        pr: Parser[R],
        ps: Parser[S],
        pt: Parser[T]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: s :: t :: u :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk),
          pair(l, pl),
          pair(m, pm),
          pair(n, pn),
          pair(o, po),
          pair(p, pp),
          pair(q, pq),
          pair(r, pr),
          pair(s, ps),
          pair(t, pt)
        ).tupled <* endParser(u)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K],
        pl: Parser[L],
        pm: Parser[M],
        pn: Parser[N],
        po: Parser[O],
        pp: Parser[P],
        pq: Parser[Q],
        pr: Parser[R],
        ps: Parser[S],
        pt: Parser[T],
        pu: Parser[U]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: s :: t :: u :: v :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk),
          pair(l, pl),
          pair(m, pm),
          pair(n, pn),
          pair(o, po),
          pair(p, pp),
          pair(q, pq),
          pair(r, pr),
          pair(s, ps),
          pair(t, pt),
          pair(u, pu)
        ).tupled <* endParser(v)
    }

    def p[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](
        pa: Parser[A],
        pb: Parser[B],
        pc: Parser[C],
        pd: Parser[D],
        pe: Parser[E],
        pf: Parser[F],
        pg: Parser[G],
        ph: Parser[H],
        pi: Parser[I],
        pj: Parser[J],
        pk: Parser[K],
        pl: Parser[L],
        pm: Parser[M],
        pn: Parser[N],
        po: Parser[O],
        pp: Parser[P],
        pq: Parser[Q],
        pr: Parser[R],
        ps: Parser[S],
        pt: Parser[T],
        pu: Parser[U],
        pv: Parser[V]
    ): Parser[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)] = nonEmptyParts match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: s :: t :: u :: v :: w :: Nil =>
        (
          pair(a, pa),
          pair(b, pb),
          pair(c, pc),
          pair(d, pd),
          pair(e, pe),
          pair(f, pf),
          pair(g, pg),
          pair(h, ph),
          pair(i, pi),
          pair(j, pj),
          pair(k, pk),
          pair(l, pl),
          pair(m, pm),
          pair(n, pn),
          pair(o, po),
          pair(p, pp),
          pair(q, pq),
          pair(r, pr),
          pair(s, ps),
          pair(t, pt),
          pair(u, pu),
          pair(v, pv)
        ).tupled <* endParser(w)
    }

    def p0[A](pa: Parser0[A]): Parser0[(A)] = sc.parts.toList match {
      case a :: b :: Nil =>
        (pair0(a, pa)) <* endParser0(b)
    }

    def p0[A, B](pa: Parser0[A], pb: Parser0[B]): Parser0[(A, B)] = sc.parts.toList match {
      case a :: b :: c :: Nil =>
        (pair0(a, pa), pair0(b, pb)).tupled <* endParser0(c)
    }

    def p0[A, B, C](pa: Parser0[A], pb: Parser0[B], pc: Parser0[C]): Parser0[(A, B, C)] = sc.parts.toList match {
      case a :: b :: c :: d :: Nil =>
        (pair0(a, pa), pair0(b, pb), pair0(c, pc)).tupled <* endParser0(d)
    }

    def p0[A, B, C, D](pa: Parser0[A], pb: Parser0[B], pc: Parser0[C], pd: Parser0[D]): Parser0[(A, B, C, D)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: Nil =>
        (pair0(a, pa), pair0(b, pb), pair0(c, pc), pair0(d, pd)).tupled <* endParser0(e)
    }

    def p0[A, B, C, D, E](pa: Parser0[A], pb: Parser0[B], pc: Parser0[C], pd: Parser0[D], pe: Parser0[E]): Parser0[(A, B, C, D, E)] =
      sc.parts.toList match {
        case a :: b :: c :: d :: e :: f :: Nil =>
          (pair0(a, pa), pair0(b, pb), pair0(c, pc), pair0(d, pd), pair0(e, pe)).tupled <* endParser0(f)
      }

    def p0[A, B, C, D, E, F](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F]
    ): Parser0[(A, B, C, D, E, F)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: Nil =>
        (pair0(a, pa), pair0(b, pb), pair0(c, pc), pair0(d, pd), pair0(e, pe), pair0(f, pf)).tupled <* endParser0(g)
    }

    def p0[A, B, C, D, E, F, G](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G]
    ): Parser0[(A, B, C, D, E, F, G)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: Nil =>
        (pair0(a, pa), pair0(b, pb), pair0(c, pc), pair0(d, pd), pair0(e, pe), pair0(f, pf), pair0(g, pg)).tupled <* endParser0(h)
    }

    def p0[A, B, C, D, E, F, G, H](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H]
    ): Parser0[(A, B, C, D, E, F, G, H)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph)
        ).tupled <* endParser0(i)
    }

    def p0[A, B, C, D, E, F, G, H, I](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I]
    ): Parser0[(A, B, C, D, E, F, G, H, I)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi)
        ).tupled <* endParser0(j)
    }

    def p0[A, B, C, D, E, F, G, H, I, J](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj)
        ).tupled <* endParser0(k)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk)
        ).tupled <* endParser0(l)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K, L](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K],
        pl: Parser0[L]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K, L)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk),
          pair0(l, pl)
        ).tupled <* endParser0(m)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K, L, M](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K],
        pl: Parser0[L],
        pm: Parser0[M]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K, L, M)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk),
          pair0(l, pl),
          pair0(m, pm)
        ).tupled <* endParser0(n)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K, L, M, N](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K],
        pl: Parser0[L],
        pm: Parser0[M],
        pn: Parser0[N]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K, L, M, N)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk),
          pair0(l, pl),
          pair0(m, pm),
          pair0(n, pn)
        ).tupled <* endParser0(o)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K],
        pl: Parser0[L],
        pm: Parser0[M],
        pn: Parser0[N],
        po: Parser0[O]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk),
          pair0(l, pl),
          pair0(m, pm),
          pair0(n, pn),
          pair0(o, po)
        ).tupled <* endParser0(p)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K],
        pl: Parser0[L],
        pm: Parser0[M],
        pn: Parser0[N],
        po: Parser0[O],
        pp: Parser0[P]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk),
          pair0(l, pl),
          pair0(m, pm),
          pair0(n, pn),
          pair0(o, po),
          pair0(p, pp)
        ).tupled <* endParser0(q)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K],
        pl: Parser0[L],
        pm: Parser0[M],
        pn: Parser0[N],
        po: Parser0[O],
        pp: Parser0[P],
        pq: Parser0[Q]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk),
          pair0(l, pl),
          pair0(m, pm),
          pair0(n, pn),
          pair0(o, po),
          pair0(p, pp),
          pair0(q, pq)
        ).tupled <* endParser0(r)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K],
        pl: Parser0[L],
        pm: Parser0[M],
        pn: Parser0[N],
        po: Parser0[O],
        pp: Parser0[P],
        pq: Parser0[Q],
        pr: Parser0[R]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: s :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk),
          pair0(l, pl),
          pair0(m, pm),
          pair0(n, pn),
          pair0(o, po),
          pair0(p, pp),
          pair0(q, pq),
          pair0(r, pr)
        ).tupled <* endParser0(s)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K],
        pl: Parser0[L],
        pm: Parser0[M],
        pn: Parser0[N],
        po: Parser0[O],
        pp: Parser0[P],
        pq: Parser0[Q],
        pr: Parser0[R],
        ps: Parser0[S]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: s :: t :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk),
          pair0(l, pl),
          pair0(m, pm),
          pair0(n, pn),
          pair0(o, po),
          pair0(p, pp),
          pair0(q, pq),
          pair0(r, pr),
          pair0(s, ps)
        ).tupled <* endParser0(t)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K],
        pl: Parser0[L],
        pm: Parser0[M],
        pn: Parser0[N],
        po: Parser0[O],
        pp: Parser0[P],
        pq: Parser0[Q],
        pr: Parser0[R],
        ps: Parser0[S],
        pt: Parser0[T]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: s :: t :: u :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk),
          pair0(l, pl),
          pair0(m, pm),
          pair0(n, pn),
          pair0(o, po),
          pair0(p, pp),
          pair0(q, pq),
          pair0(r, pr),
          pair0(s, ps),
          pair0(t, pt)
        ).tupled <* endParser0(u)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K],
        pl: Parser0[L],
        pm: Parser0[M],
        pn: Parser0[N],
        po: Parser0[O],
        pp: Parser0[P],
        pq: Parser0[Q],
        pr: Parser0[R],
        ps: Parser0[S],
        pt: Parser0[T],
        pu: Parser0[U]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: s :: t :: u :: v :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk),
          pair0(l, pl),
          pair0(m, pm),
          pair0(n, pn),
          pair0(o, po),
          pair0(p, pp),
          pair0(q, pq),
          pair0(r, pr),
          pair0(s, ps),
          pair0(t, pt),
          pair0(u, pu)
        ).tupled <* endParser0(v)
    }

    def p0[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](
        pa: Parser0[A],
        pb: Parser0[B],
        pc: Parser0[C],
        pd: Parser0[D],
        pe: Parser0[E],
        pf: Parser0[F],
        pg: Parser0[G],
        ph: Parser0[H],
        pi: Parser0[I],
        pj: Parser0[J],
        pk: Parser0[K],
        pl: Parser0[L],
        pm: Parser0[M],
        pn: Parser0[N],
        po: Parser0[O],
        pp: Parser0[P],
        pq: Parser0[Q],
        pr: Parser0[R],
        ps: Parser0[S],
        pt: Parser0[T],
        pu: Parser0[U],
        pv: Parser0[V]
    ): Parser0[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)] = sc.parts.toList match {
      case a :: b :: c :: d :: e :: f :: g :: h :: i :: j :: k :: l :: m :: n :: o :: p :: q :: r :: s :: t :: u :: v :: w :: Nil =>
        (
          pair0(a, pa),
          pair0(b, pb),
          pair0(c, pc),
          pair0(d, pd),
          pair0(e, pe),
          pair0(f, pf),
          pair0(g, pg),
          pair0(h, ph),
          pair0(i, pi),
          pair0(j, pj),
          pair0(k, pk),
          pair0(l, pl),
          pair0(m, pm),
          pair0(n, pn),
          pair0(o, po),
          pair0(p, pp),
          pair0(q, pq),
          pair0(r, pr),
          pair0(s, ps),
          pair0(t, pt),
          pair0(u, pu),
          pair0(v, pv)
        ).tupled <* endParser0(w)
    }

  }
}
